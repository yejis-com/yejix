<style>
  .links line {
    stroke: #ccc;
    opacity: 0.5;
  }

  .nodes circle {
    cursor: pointer;
    fill: #8b88e6;
    transition: all 0.15s ease-out;
  }

  .text text {
    cursor: pointer;
    fill: #333;
    text-shadow: -1px -1px 0 #fafafabb, 1px -1px 0 #fafafabb, -1px 1px 0 #fafafabb, 1px 1px 0 #fafafabb;
  }

  .nodes [active],
  .text [active] {
    cursor: pointer;
    fill: black;
  }

  .inactive {
    opacity: 0.1;
    transition: all 0.15s ease-out;
  }

  #graph-wrapper {
    background: #fcfcfc;
    border-radius: 4px;
    height: auto;
  }
  
  #graph-wrapper > svg {
    max-width: 100%;
    display: block;
  }
</style>

<div id="graph-wrapper">
  <script>
    window.addEventListener("load", loadGraph);

    function loadGraph() {
      var oScript = document.createElement("script");
      oScript.src = "https://cdnjs.cloudflare.com/ajax/libs/d3/5.16.0/d3.min.js";
      oScript.crossOrigin = 'anonymous';
      oScript.integrity =
        "sha512-FHsFVKQ/T1KWJDGSbrUhTJyS1ph3eRrxI228ND0EGaEp6v4a/vGwPWd3Dtd/+9cI7ccofZvl/wulICEurHN1pg==";
      document.body.appendChild(oScript);
      
      oScript.onload = function() {
        var MINIMAL_NODE_SIZE = 8;
        var MAX_NODE_SIZE = 12;
        var ACTIVE_RADIUS_FACTOR = 1.5;
        var STROKE = 1;
        var FONT_SIZE = 16;
        var TICKS = 200;
        var FONT_BASELINE = 40;
        var MAX_LABEL_LENGTH = 50;

        var svg = d3.select('#graph-wrapper')
            .append('svg')
            .attr('width', '100%')
            .attr('height', '100%')
            .attr('viewBox', [-FONT_BASELINE, -FONT_BASELINE, FONT_BASELINE * 2, FONT_BASELINE * 2].join(' '));

        // 리퀴드 태그를 통해 데이터 로드
        var graphDataStr = '{{ site.notes_graph | jsonify }}';
        var graphData = JSON.parse(graphDataStr.replace(/&quot;/g, '"'));
        
        var nodesData = graphData.nodes;
        var linksData = graphData.edges;

        linksData.forEach(function(link) {
          var source = nodesData.find(function(node) { return node.id === link.source; });
          var target = nodesData.find(function(node) { return node.id === link.target; });
          if (source && target) {
            if (!source.neighbors) source.neighbors = [];
            if (!target.neighbors) target.neighbors = [];
            source.neighbors.push(target);
            target.neighbors.push(source);
            if (!source.links) source.links = [];
            if (!target.links) target.links = [];
            source.links.push(link);
            target.links.push(link);
          }
        });

        var nodeSize = function(d) {
          if (d.neighbors && d.neighbors.length) {
            return Math.min(MAX_NODE_SIZE, MINIMAL_NODE_SIZE + d.neighbors.length / 10);
          }
          return MINIMAL_NODE_SIZE;
        };

        var simulation = createSimulation();
        
        var link = svg.append("g")
            .attr("class", "links")
            .selectAll("line")
            .data(linksData)
            .enter().append("line")
            .attr("stroke", "#ccc")
            .attr("stroke-width", STROKE);

        var node = svg.append("g")
            .attr("class", "nodes")
            .selectAll("circle")
            .data(nodesData)
            .enter().append("circle")
            .attr("r", nodeSize)
            .attr("fill", "#8b88e6");

        var text = svg.append("g")
            .attr("class", "text")
            .selectAll("text")
            .data(nodesData)
            .enter().append("text")
            .attr("dy", ".1em")
            .attr("text-anchor", "middle")
            .text(function(d) { return shorten(d.label, MAX_LABEL_LENGTH); });

        simulation.nodes(nodesData).on("tick", ticked);
        simulation.force("link").links(linksData);
        
        node.on("click", function(d) {
          window.location = d.path;
        });
        
        node.on("mouseover", function(d) {
          var relatedNodesSet = new Set();
          linksData
            .filter(function(n) { return n.target.id == d.id || n.source.id == d.id; })
            .forEach(function(n) {
              relatedNodesSet.add(n.target.id);
              relatedNodesSet.add(n.source.id);
            });

          node.attr("class", function(node_d) {
            if (node_d.id !== d.id && !relatedNodesSet.has(node_d.id)) {
              return "inactive";
            }
            return "";
          });

          link.attr("class", function(link_d) {
            if (link_d.source.id !== d.id && link_d.target.id !== d.id) {
              return "inactive";
            }
            return "";
          });

          link.attr("stroke-width", function(link_d) {
            if (link_d.source.id === d.id || link_d.target.id === d.id) {
              return STROKE * 4;
            }
            return STROKE;
          });
          
          text.attr("class", function(text_d) {
            if (text_d.id !== d.id && !relatedNodesSet.has(text_d.id)) {
              return "inactive";
            }
            return "";
          });
        });
        
        node.on("mouseout", function() {
          node.attr("class", "");
          link.attr("class", "");
          text.attr("class", "");
          link.attr("stroke-width", STROKE);
        });
        
        window.updateGraphForce = function() {
          if (simulation) {
            var graphWrapper = document.getElementById('graph-wrapper');
            if (graphWrapper) {
              var width = graphWrapper.clientWidth;
              var height = graphWrapper.clientHeight;
              
              if (width > 0 && height > 0) {
                simulation.force('center', d3.forceCenter(width / 2, height / 2));
                simulation.alpha(0.3).restart();
              }
            }
          }
        };
        
        function createSimulation() {
          return d3.forceSimulation()
            .force("link", d3.forceLink()
              .id(function(d) { return d.id; })
              .distance(function() { return 40; })
            )
            .force("charge", d3.forceManyBody()
              .strength(-100)
              .distanceMax(150)
            )
            .force("center", d3.forceCenter())
            .force("collide", d3.forceCollide()
              .radius(function(d) { return nodeSize(d) * ACTIVE_RADIUS_FACTOR; })
            );
        }

        function ticked() {
          link
            .attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });
          node
            .attr("cx", function(d) { return d.x; })
            .attr("cy", function(d) { return d.y; });
          text
            .attr("x", function(d) { return d.x; })
            .attr("y", function(d) { return d.y; });
        }

        function shorten(str, maxLen, separator) {
          separator = separator || ' ';
          if (str.length <= maxLen) return str;
          return str.substr(0, str.lastIndexOf(separator, maxLen)) + '...';
        }
        
        setTimeout(updateGraphForce, 500);
      };
    }
  </script>
</div>
